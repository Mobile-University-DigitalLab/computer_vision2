if (length(files) == 0) {
warning("‚ö†Ô∏è Keine Bilddateien in: ", class_dir)
next
}
image_paths <- c(image_paths, files)
labels <- c(labels, rep(i - 1, length(files)))  # Torch: 0-basiert
}
list(paths = image_paths, labels = labels, class_names = classes)
}
# üì¶ Torch-kompatibles Dataset mit magick
BloodCellDataset <- dataset(
name = "BloodCellDataset",
initialize = function(image_paths, labels, transform = NULL) {
self$image_paths <- image_paths
self$labels <- labels
self$transform <- transform
},
.getitem = function(i) {
img_path <- as.character(self$image_paths[i])
img <- image_read(img_path) |>
image_resize("64x64!") |>
image_data() |>
as.numeric()
dims <- dim(img)
if (length(dims) == 3) {
img <- array(img, dim = c(dims[3], dims[2], dims[1]))  # CHW
}
img_tensor <- torch_tensor(img / 255, dtype = torch_float())
if (!is.null(self$transform)) {
img_tensor <- self$transform(img_tensor)
}
list(x = img_tensor, label_value <- self$labels[i]
if (!is.numeric(label_value)) stop("Label ist kein numerischer Wert: ", label_value)
library(torch)
library(fs)
library(magick)
# üìÇ Absoluter Pfad zum Bilddaten-Ordner
base_path <- "E:/bloodcelldata/dataset2-master/images"
# üì• Bildpfade & Labels laden
load_image_paths <- function(base_dir) {
if (!dir.exists(base_dir)) stop("Pfad nicht gefunden: ", base_dir)
classes <- dir_ls(base_dir, type = "directory") %>% path_file()
image_paths <- list()
labels <- c()
for (i in seq_along(classes)) {
class_dir <- file.path(base_dir, classes[i])
files <- dir_ls(class_dir, regexp = "[.](?i)(jpg|jpeg|png)$")
if (length(files) == 0) {
warning("‚ö†Ô∏è Keine Bilddateien in: ", class_dir)
next
}
image_paths <- c(image_paths, files)
labels <- c(labels, rep(i - 1, length(files)))  # Torch: 0-basiert
}
list(paths = image_paths, labels = labels, class_names = classes)
}
# üì¶ Torch-kompatibles Dataset mit magick
BloodCellDataset <- dataset(
name = "BloodCellDataset",
initialize = function(image_paths, labels, transform = NULL) {
self$image_paths <- image_paths
self$labels <- labels
self$transform <- transform
},
.getitem = function(i) {
img_path <- as.character(self$image_paths[i])
img <- image_read(img_path) |>
image_resize("64x64!") |>
image_data() |>
as.numeric()
dims <- dim(img)
if (length(dims) == 3) {
img <- array(img, dim = c(dims[3], dims[2], dims[1]))  # CHW
}
img_tensor <- torch_tensor(img / 255, dtype = torch_float())
if (!is.null(self$transform)) {
img_tensor <- self$transform(img_tensor)
}
list(x = img_tensor, y = torch_tensor(self$labels[i])$to(dtype = torch_long()))
},
.length = function() {
length(self$image_paths)
}
)
# üîç Bildvorschau
visualize_samples <- function(dataset, n = 6, class_names = NULL) {
par(mfrow = c(2, ceiling(n / 2)), mar = c(1, 1, 2, 1))
for (i in 1:n) {
sample <- dataset$.getitem(i)
img <- as.array(sample$x$permute(c(2, 3, 1)))
label <- sample$y$item()
plot.new()
rasterImage(img, 0, 0, 1, 1)
title(if (!is.null(class_names)) class_names[label + 1] else paste("Label:", label))
}
}
# üèãÔ∏è Training
train_model <- function(model, train_dl, test_dl, epochs = 5, device = "cpu") {
model$to(device)
optimizer <- optim_adam(model$parameters, lr = 0.001)
for (epoch in 1:epochs) {
model$train()
total_loss <- 0
coro::loop(for (batch in train_dl) {
optimizer$zero_grad()
output <- model(batch[[1]]$to(device))
loss <- nnf_cross_entropy(output, batch[[2]]$to(device))
loss$backward()
optimizer$step()
total_loss <- total_loss + loss$item()
})
cat(sprintf("Epoch %d: Verlust = %.4f\n", epoch, total_loss))
}
model$eval()
correct <- 0
total <- 0
coro::loop(for (batch in test_dl) {
output <- model(batch[[1]]$to(device))
pred <- output$argmax(dim = 2)
correct <- correct + (pred == batch[[2]]$to(device))$sum()$item()
total <- total + batch[[2]]$size(1)
})
cat(sprintf("Testgenauigkeit: %.2f%%\n", 100 * correct / total))
}
# üîç Einzelbild-Vorhersage
predict_image <- function(model, dataset, index = 1, class_names = NULL, device = "cpu") {
model$eval()
sample <- dataset$.getitem(index)
x <- sample$x$unsqueeze(1)$to(device)
pred <- model(x)$argmax(dim = 2)$item()
true <- sample$y$item()
img <- as.array(sample$x$permute(c(2, 3, 1)))
plot.new()
rasterImage(img, 0, 0, 1, 1)
title(sprintf("Wahr: %s | Vorhergesagt: %s",
class_names[true + 1], class_names[pred + 1]))
}
# ‚ñ∂Ô∏è Starten
run_pipeline()
library(torch)
library(fs)
library(magick)
# üìÇ Absoluter Pfad zum Bilddaten-Ordner
base_path <- "E:/bloodcelldata/dataset2-master/images"
# üì• Bildpfade & Labels laden
load_image_paths <- function(base_dir) {
if (!dir.exists(base_dir)) stop("Pfad nicht gefunden: ", base_dir)
classes <- dir_ls(base_dir, type = "directory") %>% path_file()
image_paths <- list()
labels <- c()
for (i in seq_along(classes)) {
class_dir <- file.path(base_dir, classes[i])
files <- dir_ls(class_dir, regexp = "[.](?i)(jpg|jpeg|png)$")
if (length(files) == 0) {
warning("‚ö†Ô∏è Keine Bilddateien in: ", class_dir)
next
}
image_paths <- c(image_paths, files)
labels <- c(labels, rep(i - 1, length(files)))  # Torch: 0-basiert
}
list(paths = image_paths, labels = labels, class_names = classes)
}
# üì¶ Torch-kompatibles Dataset mit magick
BloodCellDataset <- dataset(
name = "BloodCellDataset",
initialize = function(image_paths, labels, transform = NULL) {
self$image_paths <- image_paths
self$labels <- labels
self$transform <- transform
},
.getitem = function(i) {
img_path <- as.character(self$image_paths[i])
img <- image_read(img_path) |>
image_resize("64x64!") |>
image_data() |>
as.numeric()
dims <- dim(img)
if (length(dims) == 3) {
img <- array(img, dim = c(dims[3], dims[2], dims[1]))  # CHW
}
img_tensor <- torch_tensor(img / 255, dtype = torch_float())
if (!is.null(self$transform)) {
img_tensor <- self$transform(img_tensor)
}
list(x = img_tensor, y = torch_tensor(self$labels[i])$to(dtype = torch_long()))
},
.length = function() {
length(self$image_paths)
}
)
# üîç Bildvorschau
visualize_samples <- function(dataset, n = 6, class_names = NULL) {
par(mfrow = c(2, ceiling(n / 2)), mar = c(1, 1, 2, 1))
for (i in 1:n) {
sample <- dataset$.getitem(i)
img <- as.array(sample$x$permute(c(2, 3, 1)))
label <- sample$y$item()
plot.new()
rasterImage(img, 0, 0, 1, 1)
title(if (!is.null(class_names)) class_names[label + 1] else paste("Label:", label))
}
}
# üß† Einfaches CNN
SimpleCNN <- nn_module(
initialize = function() {
self$conv1 <- nn_conv2d(3, 16, kernel_size = 3, padding = 1)
self$conv2 <- nn_conv2d(16, 32, kernel_size = 3, padding = 1)
self$pool <- nn_max_pool2d(kernel_size = 2)
self$fc1 <- nn_linear(32 * 16 * 16, 64)
self$fc2 <- nn_linear(64, 4)
},
forward = function(x) {
x <- self$pool(nnf_relu(self$conv1(x)))
x <- self$pool(nnf_relu(self$conv2(x)))
x <- x$view(c(x$size(1), -1))
x <- nnf_relu(self$fc1(x))
self$fc2(x)
}
)
# üèãÔ∏è Training
train_model <- function(model, train_dl, test_dl, epochs = 5, device = "cpu") {
model$to(device)
optimizer <- optim_adam(model$parameters, lr = 0.001)
for (epoch in 1:epochs) {
model$train()
total_loss <- 0
coro::loop(for (batch in train_dl) {
optimizer$zero_grad()
output <- model(batch[[1]]$to(device))
loss <- nnf_cross_entropy(output, batch[[2]]$to(device))
loss$backward()
optimizer$step()
total_loss <- total_loss + loss$item()
})
cat(sprintf("Epoch %d: Verlust = %.4f\n", epoch, total_loss))
}
model$eval()
correct <- 0
total <- 0
coro::loop(for (batch in test_dl) {
output <- model(batch[[1]]$to(device))
pred <- output$argmax(dim = 2)
correct <- correct + (pred == batch[[2]]$to(device))$sum()$item()
total <- total + batch[[2]]$size(1)
})
cat(sprintf("Testgenauigkeit: %.2f%%\n", 100 * correct / total))
}
# üîç Einzelbild-Vorhersage
predict_image <- function(model, dataset, index = 1, class_names = NULL, device = "cpu") {
model$eval()
sample <- dataset$.getitem(index)
x <- sample$x$unsqueeze(1)$to(device)
pred <- model(x)$argmax(dim = 2)$item()
true <- sample$y$item()
img <- as.array(sample$x$permute(c(2, 3, 1)))
plot.new()
rasterImage(img, 0, 0, 1, 1)
title(sprintf("Wahr: %s | Vorhergesagt: %s",
class_names[true + 1], class_names[pred + 1]))
}
# üöÄ Hauptpipeline
run_pipeline <- function() {
train_info <- load_image_paths(file.path(base_path, "TRAIN"))
test_info  <- load_image_paths(file.path(base_path, "TEST"))
train_ds <- BloodCellDataset(train_info$paths, train_info$labels)
test_ds  <- BloodCellDataset(test_info$paths, test_info$labels)
visualize_samples(train_ds, 6, class_names = train_info$class_names)
train_dl <- dataloader(train_ds, batch_size = 32, shuffle = TRUE)
test_dl  <- dataloader(test_ds, batch_size = 128)
model <- SimpleCNN()
device <- if (cuda_is_available()) torch_device("cuda") else torch_device("cpu")
train_model(model, train_dl, test_dl, device = device)
predict_image(model, test_ds, index = 2, class_names = test_info$class_names, device = device)
}
label <- sample$y$item()
visualize_samples <- function(dataset, n = 6, class_names = NULL) {
par(mfrow = c(2, ceiling(n / 2)), mar = c(1, 1, 2, 1))
for (i in 1:n) {
sample <- dataset$.getitem(i)
img <- as.array(sample$x$permute(c(2, 3, 1)))
label <- sample$y$item()
plot.new()
rasterImage(img, 0, 0, 1, 1)
title(if (!is.null(class_names)) class_names[label + 1] else paste("Label:", label))
}
}
print()
sample <- train_ds$.getitem(1)
library(torch)
library(fs)
library(magick)
library(ggplot2)
library(grid)
library(gridExtra)
base_path <- "E:/bloodcelldata/dataset2-master/images"
# üóÇÔ∏è Bildpfade + Labels laden
load_image_paths <- function(base_dir) {
if (!dir.exists(base_dir)) stop("Pfad nicht gefunden: ", base_dir)
classes <- dir_ls(base_dir, type = "directory") %>% path_file()
image_paths <- list()
labels <- c()
for (i in seq_along(classes)) {
class_dir <- file.path(base_dir, classes[i])
files <- dir_ls(class_dir, regexp = "[.](?i)(jpg|jpeg|png)$")
if (length(files) == 0) {
warning("‚ö†Ô∏è Keine Bilder in: ", class_dir)
next
}
image_paths <- c(image_paths, files)
labels <- c(labels, rep(i - 1, length(files)))
}
list(paths = image_paths, labels = labels, class_names = classes)
}
# üß± Torch-kompatibles Dataset
BloodCellDataset <- dataset(
name = "BloodCellDataset",
initialize = function(image_paths, labels) {
self$image_paths <- image_paths
self$labels <- labels
},
.getitem = function(i) {
img_path <- as.character(self$image_paths[i])
img <- image_read(img_path) |>
image_resize("64x64!") |>
image_data() |>
as.numeric()
dims <- dim(img)
if (length(dims) == 3) {
img <- array(img, dim = c(dims[3], dims[2], dims[1]))  # CHW
}
x <- torch_tensor(img / 255, dtype = torch_float())
y <- torch_tensor(as.integer(self$labels[i]), dtype = torch_long())
list(x = x, y = y)
},
.length = function() {
length(self$image_paths)
}
)
# üñºÔ∏è GGPlot-Vorschau von n Bildern
visualize_samples <- function(dataset, n = 6, class_names = NULL) {
plots <- list()
for (i in 1:n) {
sample <- dataset$.getitem(i)
img_tensor <- sample$x
if (img_tensor$size(1) == 1) {
img_tensor <- img_tensor$repeat(c(3, 1, 1))
library(torch)
library(magick)
library(ggplot2)
base_path <- "E:/bloodcelldata/dataset2-master/images"
# Daten laden
load_image_paths <- function(dir) {
classes <- list.dirs(dir, full.names = FALSE, recursive = FALSE)
paths <- c(); labels <- c()
for (i in seq_along(classes)) {
f <- list.files(file.path(dir, classes[i]), pattern = "\\.(jpg|jpeg|png)$", full.names = TRUE, ignore.case = TRUE)
paths <- c(paths, f)
labels <- c(labels, rep(i - 1, length(f)))
}
list(paths = paths, labels = labels, class_names = classes)
}
# Dataset
BloodCellDataset <- dataset(
initialize = function(paths, labels) {
self$paths <- paths; self$labels <- labels
},
.getitem = function(i) {
img <- image_read(self$paths[i]) |> image_resize("64x64!") |> image_data() |> as.numeric()
d <- dim(img); img <- array(img, c(d[3], d[2], d[1]))
list(x = torch_tensor(img / 255, dtype = torch_float()), y = torch_tensor(self$labels[i], dtype = torch_long()))
},
.length = function() length(self$paths)
)
# Visualisierung
show_image <- function(sample, class_names) {
img <- as.array(sample$x$permute(c(2,3,1)))
df <- as.data.frame(as.table(img)); names(df) <- c("x","y","c","v")
ggplot(df, aes(x, y, fill=v)) + geom_raster() + facet_wrap(~c) +
coord_fixed() + scale_fill_gradient(low="black", high="white") +
theme_void() + ggtitle(class_names[sample$y$item()+1])
}
# Modell
SimpleCNN <- nn_module(
initialize = function() {
self$conv1 <- nn_conv2d(3, 16, 3, padding = 1)
self$conv2 <- nn_conv2d(16, 32, 3, padding = 1)
self$pool <- nn_max_pool2d(2)
self$fc1 <- nn_linear(32 * 16 * 16, 64)
self$fc2 <- nn_linear(64, 4)
},
forward = function(x) {
x %>% self$conv1() %>% nnf_relu() %>% self$pool() %>%
self$conv2() %>% nnf_relu() %>% self$pool() %>%
(\(z) z$view(c(z$size(1), -1)))() %>%
self$fc1() %>% nnf_relu() %>% self$fc2()
}
)
# Hauptlauf
run <- function() {
train <- load_image_paths(file.path(base_path, "TRAIN"))
test  <- load_image_paths(file.path(base_path, "TEST"))
ds_train <- BloodCellDataset(train$paths, train$labels)
ds_test  <- BloodCellDataset(test$paths, test$labels)
show_image(ds_train$.getitem(1), train$class_names)
model <- SimpleCNN()
opt <- optim_adam(model$parameters, lr=0.001)
train_dl <- dataloader(ds_train, batch_size=32, shuffle=TRUE)
model$train()
coro::loop(for (b in train_dl) {
opt$zero_grad()
out <- model(b$x); loss <- nnf_cross_entropy(out, b$y)
loss$backward(); opt$step()
})
model$eval()
sample <- ds_test$.getitem(1)
pred <- model(sample$x$unsqueeze(1))$argmax(dim=2)$item()
cat("Vorhersage:", test$class_names[pred + 1], "\n")
}
run()
rm(list=ls())
#install.packages("torch")
#install.packages("(torchvision")
#install.packages("torchaudio")
#install.packages("luz")
#install.packages("reshape2")
library(torch)
library(torchvision)
library(luz)
library(reshape2)
library(ggplot2)
dir <- "./dataset/mnist"
train_ds <- mnist_dataset(
dir,
download = TRUE,
transform = transform_to_tensor
)
rm(list=ls())
#install.packages("torch")
#install.packages("(torchvision")
#install.packages("torchaudio")
#install.packages("luz")
#install.packages("reshape2")
library(torch)
library(torchvision)
library(luz)
library(reshape2)
library(ggplot2)
dir <- "./dataset/mnist"
train_ds <- mnist_dataset(
dir,
download = TRUE,
transform = transform_to_tensor
)
rm(list=ls())
#install.packages("torch")
#install.packages("(torchvision")
#install.packages("torchaudio")
#install.packages("luz")
#install.packages("reshape2")
library(torch)
library(torchvision)
library(luz)
library(reshape2)
library(ggplot2)
dir <- "./dataset/mnist"
train_ds <- mnist_dataset(
dir,
download = TRUE,
transform = transform_to_tensor
)
rm(list=ls())
#install.packages("torch")
#install.packages("(torchvision")
#install.packages("torchaudio")
#install.packages("luz")
#install.packages("reshape2")
library(torch)
library(torchvision)
library(luz)
library(reshape2)
library(ggplot2)
dir <- "./dataset/mnist"
train_ds <- mnist_dataset(
dir,
download = TRUE,
transform = transform_to_tensor
)
rm(list=ls())
#install.packages("torch")
#install.packages("(torchvision")
#install.packages("torchaudio")
#install.packages("luz")
#install.packages("reshape2")
library(torch)
library(torchvision)
library(luz)
library(reshape2)
library(ggplot2)
dir <- "./dataset/mnist"
train_ds <- mnist_dataset(
dir,
download = TRUE,
transform = transform_to_tensor
)
torch::torch_is_installed()
sessionInfo()
dir <- "./dataset/mnist"
train_ds <- mnist_dataset(
dir,
download = TRUE,
transform = transform_to_tensor
)
