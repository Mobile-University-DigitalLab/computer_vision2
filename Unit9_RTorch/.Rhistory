BloodCellDataset <- dataset(
initialize = function(paths, labels) {
self$paths <- paths; self$labels <- labels
},
.getitem = function(i) {
img <- image_read(self$paths[i]) |> image_resize("64x64!") |> image_data() |> as.numeric()
d <- dim(img); img <- array(img, c(d[3], d[2], d[1]))
list(x = torch_tensor(img / 255, dtype = torch_float()), y = torch_tensor(self$labels[i], dtype = torch_long()))
},
.length = function() length(self$paths)
)
# Visualisierung
show_image <- function(sample, class_names) {
img <- as.array(sample$x$permute(c(2,3,1)))
df <- as.data.frame(as.table(img)); names(df) <- c("x","y","c","v")
ggplot(df, aes(x, y, fill=v)) + geom_raster() + facet_wrap(~c) +
coord_fixed() + scale_fill_gradient(low="black", high="white") +
theme_void() + ggtitle(class_names[sample$y$item()+1])
}
# Modell
SimpleCNN <- nn_module(
initialize = function() {
self$conv1 <- nn_conv2d(3, 16, 3, padding = 1)
self$conv2 <- nn_conv2d(16, 32, 3, padding = 1)
self$pool <- nn_max_pool2d(2)
self$fc1 <- nn_linear(32 * 16 * 16, 64)
self$fc2 <- nn_linear(64, 4)
},
forward = function(x) {
x %>% self$conv1() %>% nnf_relu() %>% self$pool() %>%
self$conv2() %>% nnf_relu() %>% self$pool() %>%
(\(z) z$view(c(z$size(1), -1)))() %>%
self$fc1() %>% nnf_relu() %>% self$fc2()
}
)
# Hauptlauf
run <- function() {
train <- load_image_paths(file.path(base_path, "TRAIN"))
test  <- load_image_paths(file.path(base_path, "TEST"))
ds_train <- BloodCellDataset(train$paths, train$labels)
ds_test  <- BloodCellDataset(test$paths, test$labels)
show_image(ds_train$.getitem(1), train$class_names)
model <- SimpleCNN()
opt <- optim_adam(model$parameters, lr=0.001)
train_dl <- dataloader(ds_train, batch_size=32, shuffle=TRUE)
model$train()
coro::loop(for (b in train_dl) {
opt$zero_grad()
out <- model(b$x); loss <- nnf_cross_entropy(out, b$y)
loss$backward(); opt$step()
})
model$eval()
sample <- ds_test$.getitem(1)
pred <- model(sample$x$unsqueeze(1))$argmax(dim=2)$item()
cat("Vorhersage:", test$class_names[pred + 1], "\n")
}
run()
rm(list=ls())
#install.packages("torch")
#install.packages("(torchvision")
#install.packages("torchaudio")
#install.packages("luz")
#install.packages("reshape2")
library(torch)
library(torchvision)
library(luz)
library(reshape2)
library(ggplot2)
dir <- "./dataset/mnist"
train_ds <- mnist_dataset(
dir,
download = TRUE,
transform = transform_to_tensor
)
rm(list=ls())
#install.packages("torch")
#install.packages("(torchvision")
#install.packages("torchaudio")
#install.packages("luz")
#install.packages("reshape2")
library(torch)
library(torchvision)
library(luz)
library(reshape2)
library(ggplot2)
dir <- "./dataset/mnist"
train_ds <- mnist_dataset(
dir,
download = TRUE,
transform = transform_to_tensor
)
rm(list=ls())
#install.packages("torch")
#install.packages("(torchvision")
#install.packages("torchaudio")
#install.packages("luz")
#install.packages("reshape2")
library(torch)
library(torchvision)
library(luz)
library(reshape2)
library(ggplot2)
dir <- "./dataset/mnist"
train_ds <- mnist_dataset(
dir,
download = TRUE,
transform = transform_to_tensor
)
rm(list=ls())
#install.packages("torch")
#install.packages("(torchvision")
#install.packages("torchaudio")
#install.packages("luz")
#install.packages("reshape2")
library(torch)
library(torchvision)
library(luz)
library(reshape2)
library(ggplot2)
dir <- "./dataset/mnist"
train_ds <- mnist_dataset(
dir,
download = TRUE,
transform = transform_to_tensor
)
rm(list=ls())
#install.packages("torch")
#install.packages("(torchvision")
#install.packages("torchaudio")
#install.packages("luz")
#install.packages("reshape2")
library(torch)
library(torchvision)
library(luz)
library(reshape2)
library(ggplot2)
dir <- "./dataset/mnist"
train_ds <- mnist_dataset(
dir,
download = TRUE,
transform = transform_to_tensor
)
torch::torch_is_installed()
sessionInfo()
dir <- "./dataset/mnist"
train_ds <- mnist_dataset(
dir,
download = TRUE,
transform = transform_to_tensor
)
rm(list=ls())
#install.packages("torch")
#install.packages("(torchvision")
#install.packages("torchaudio")
#install.packages("luz")
#install.packages("reshape2")
library(torch)
library(torchvision)
library(luz)
library(reshape2)
library(ggplot2)
#remove.packages("rappdirs")     Falls Probleme auftreten
#install.packages("rappdirs")
dir <- "./dataset/mnist"
train_ds <- mnist_dataset(
dir,
download = TRUE,
transform = transform_to_tensor
)
#install.packages("torch")
#install.packages("(torchvision")
#install.packages("torchaudio")
#install.packages("luz")
#install.packages("reshape2")
library(torch)
library(torchvision)
library(luz)
library(reshape2)
library(ggplot2)
remove.packages("rappdirs")     Falls Probleme auftreten
#install.packages("torch")
#install.packages("(torchvision")
#install.packages("torchaudio")
#install.packages("luz")
#install.packages("reshape2")
library(torch)
library(torchvision)
library(luz)
library(reshape2)
library(ggplot2)
remove.packages("rappdirs")    # Falls Probleme auftreten
install.packages("rappdirs")
dir <- "./dataset/mnist"
train_ds <- mnist_dataset(
dir,
download = TRUE,
transform = transform_to_tensor
)
test_ds <- mnist_dataset(
dir,
train = FALSE,
transform = transform_to_tensor
)
train_dl <- dataloader(train_ds, batch_size = 128, shuffle = TRUE)
test_dl <- dataloader(test_ds, batch_size = 128)
image_matrix <- as.matrix(train_ds$data[1, 1:28, 1:28])
image_df <- melt(image_matrix)
ggplot(image_df, aes(x=Var2, y=Var1, fill=value))+
geom_tile(show.legend = FALSE) +
xlab("") + ylab("") +
scale_fill_gradient(low="white", high="black")
net <- nn_module(
"Net",
initialize = function() {
self$conv1 <- nn_conv2d(1, 32, 3, 1)
self$conv2 <- nn_conv2d(32, 64, 3, 1)
self$dropout1 <- nn_dropout(0.25)
self$dropout2 <- nn_dropout(0.5)
self$fc1 <- nn_linear(9216, 128)
self$fc2 <- nn_linear(128, 10)
},
forward = function(x) {
x %>%
self$conv1() %>%
nnf_relu() %>%
self$conv2() %>%
nnf_relu() %>%
nnf_max_pool2d(2) %>%
self$dropout1() %>%
torch_flatten(start_dim = 2) %>%
self$fc1() %>%
nnf_relu() %>%
self$dropout2() %>%
self$fc2()
}
)
fitted <- net %>%
setup(
loss = nn_cross_entropy_loss(),
optimizer = optim_adam,
metrics = list(
luz_metric_accuracy()
)
) %>%
fit(train_dl, epochs = 1, valid_data = test_dl) # Epochen können hier justiert werden
preds <- predict(fitted, test_dl)
preds$shape
luz_save(fitted, "mnist-cnn.pt")
# 1. Deine Netzarchitektur
net <- nn_module(
"Net",
initialize = function() {
self$conv1 <- nn_conv2d(1, 32, 3, 1)
self$conv2 <- nn_conv2d(32, 64, 3, 1)
self$dropout1 <- nn_dropout(0.25)
self$dropout2 <- nn_dropout(0.5)
self$fc1 <- nn_linear(9216, 128)
self$fc2 <- nn_linear(128, 10)
},
forward = function(x) {
x %>%
self$conv1() %>%
nnf_relu() %>%
self$conv2() %>%
nnf_relu() %>%
nnf_max_pool2d(2) %>%
self$dropout1() %>%
torch_flatten(start_dim = 2) %>%
self$fc1() %>%
nnf_relu() %>%
self$dropout2() %>%
self$fc2()
}
)
# 2. Modell laden
model <- luz_load("mnist-cnn.pt")
print(model)
library(magick)
# Bild-URL (Beispiel)
#img <- image_read("../images/Predictfour.png")
img <- image_read("../images/Predictfour.png")
plot(img)
arr <- image_data(img, channels = "gray")
img_matrix <- as.numeric(arr[1, , ])
img_matrix <- matrix(img_matrix, nrow = 28, ncol = 28, byrow = TRUE)
img_matrix <- img_matrix / 255
img_tensor <- torch_tensor(img_matrix, dtype = torch_float())
img_tensor <- img_tensor$unsqueeze(1)$unsqueeze(1)
prediction <- predict(model, img_tensor)
pred_class <- as.array(prediction$argmax(dim = 2))
cat("Vorhergesagte Ziffer:", pred_class, "\n")
# Bild vorbereiten
img_array <- as.numeric(image_data(img, channels = "gray")[1,,])
img_matrix <- matrix(img_array, nrow = 28, ncol = 28)
img_matrix <- img_matrix / 255
# Tensor erzeugen
img_tensor <- torch_tensor(img_matrix, dtype = torch_float())
img_tensor <- img_tensor$unsqueeze(1)$unsqueeze(1)  # [1, 1, 28, 28]
# Vorhersage
prediction <- predict(model, img_tensor)
# Zugriff ohne [[1]] !
pred_class <- as.array(prediction$argmax(dim = 2))
cat("Vorhergesagte Ziffer:", pred_class, "\n")
rm(list=ls())
if (!require("imager")) install.packages("imager")
library(imager)
library(imager)
plot(boats)
class(boats)
boats
grayscale(boats)
dim(boats)
log(boats)+3*sqrt(boats)
mean(boats)
sd(boats)
exampleimage <- load.image("https://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Riedlingen_-_Stadt_%C3%BCber_der_Donau.JPG/1200px-Riedlingen_-_Stadt_%C3%BCber_der_Donau.JPG")
plot(exampleimage)
rm(list=ls())
if (!require("imager")) install.packages("imager")
library(imager)
remove.packages("rappdirs")    # Falls Probleme auftreten
install.packages("rappdirs")
library(imager)
plot(boats)
class(boats)
boats
grayscale(boats)
dim(boats)
log(boats)+3*sqrt(boats)
mean(boats)
sd(boats)
exampleimage <- load.image("https://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Riedlingen_-_Stadt_%C3%BCber_der_Donau.JPG/1200px-Riedlingen_-_Stadt_%C3%BCber_der_Donau.JPG")
plot(exampleimage)
print(exampleimage)
print(exampleimage)
plot(exampleimage)
grayscale(boats) %>% hist(main="Lumincance values in boats picture")
R(boats) %>% hist(main="Red channel values in boats picture")
library(ggplot2)
library(dplyr)
bdf <- as.data.frame(boats)
head(bdf,3)
bdf <- mutate(bdf,channel=factor(cc,labels=c('R','G','B')))
ggplot(bdf,aes(value,col=channel))+geom_histogram(bins=30)+facet_wrap(~ channel)
boats.g <- grayscale(boats)
f <- ecdf(boats.g)
plot(f,main="Empirical CDF of luminance values")
f(boats.g) %>% hist(main="Transformed luminance values")
f(boats.g) %>% as.cimg(dim=dim(boats.g)) %>% plot(main="With histogram equalisation")
#Hist. equalisation for grayscale
hist.eq <- function(im) as.cimg(ecdf(im)(im),dim=dim(im))
#Split across colour channels,
cn <- imsplit(boats,"c")
cn #we now have a list of images
cn.eq <- map_il(cn,hist.eq) #run hist.eq on each
imappend(cn.eq,"c") %>% plot(main="All channels equalised") #recombine and plot
gr <- imgradient(boats.g,"xy")
gr
plot(gr,layout="row")
im.blurry <- isoblur(boats,10) #Blurry parrots!
plot(im.blurry)
imager::save.image(boats,"boats.jpg")
print("Done")
if (!require("torch")) install.packages("torch")
library(torch)
torch_tensor(matrix(1:9, ncol=3))
torch_eye(n =5)
torch_tensor(JohnsonJohnson)
t1 <- torch_tensor(c(1, 2))
t2 <- torch_tensor(c(3, 4))
torch_add(t1, t2)
t2 <- t1$to(dtype = torch_int())
t2$dtype
t1 <- torch_tensor(c(2,7,1))
t2 <- torch_tensor(c(8,2,8))
t1$dot(t2)
t1 <- torch_tensor(1:3)
t2 <- torch_tensor(4:6)
t3 <- torch_tensor(matrix(1:12, ncol = 3, byrow = TRUE))
t3$matmul(t1)
torch_multiply(t1, t2)
t <- torch_outer(torch_tensor(1:3), torch_tensor(1:6))
t$sum()
t$sum(dim = 1)
t$sum(dim = 2)
print("Done")
print("Done")
rm(list=ls())
#install.packages("torch")
#install.packages("(torchvision")
#install.packages("torchaudio")
#install.packages("luz")
#install.packages("reshape2")
library(torch)
library(torchvision)
library(luz)
library(reshape2)
library(ggplot2)
#remove.packages("rappdirs")    # Falls Probleme auftreten
#install.packages("rappdirs")
dir <- "./dataset/mnist"
train_ds <- mnist_dataset(
dir,
download = TRUE,
transform = transform_to_tensor
)
test_ds <- mnist_dataset(
dir,
train = FALSE,
transform = transform_to_tensor
)
train_dl <- dataloader(train_ds, batch_size = 128, shuffle = TRUE)
test_dl <- dataloader(test_ds, batch_size = 128)
image_matrix <- as.matrix(train_ds$data[1, 1:28, 1:28])
image_df <- melt(image_matrix)
ggplot(image_df, aes(x=Var2, y=Var1, fill=value))+
geom_tile(show.legend = FALSE) +
xlab("") + ylab("") +
scale_fill_gradient(low="white", high="black")
net <- nn_module(
"Net",
initialize = function() {
self$conv1 <- nn_conv2d(1, 32, 3, 1)
self$conv2 <- nn_conv2d(32, 64, 3, 1)
self$dropout1 <- nn_dropout(0.25)
self$dropout2 <- nn_dropout(0.5)
self$fc1 <- nn_linear(9216, 128)
self$fc2 <- nn_linear(128, 10)
},
forward = function(x) {
x %>%
self$conv1() %>%
nnf_relu() %>%
self$conv2() %>%
nnf_relu() %>%
nnf_max_pool2d(2) %>%
self$dropout1() %>%
torch_flatten(start_dim = 2) %>%
self$fc1() %>%
nnf_relu() %>%
self$dropout2() %>%
self$fc2()
}
)
fitted <- net %>%
setup(
loss = nn_cross_entropy_loss(),
optimizer = optim_adam,
metrics = list(
luz_metric_accuracy()
)
) %>%
fit(train_dl, epochs = 1, valid_data = test_dl) # Epochen können hier justiert werden
preds <- predict(fitted, test_dl)
preds$shape
luz_save(fitted, "mnist-cnn.pt")
# 1. Deine Netzarchitektur
net <- nn_module(
"Net",
initialize = function() {
self$conv1 <- nn_conv2d(1, 32, 3, 1)
self$conv2 <- nn_conv2d(32, 64, 3, 1)
self$dropout1 <- nn_dropout(0.25)
self$dropout2 <- nn_dropout(0.5)
self$fc1 <- nn_linear(9216, 128)
self$fc2 <- nn_linear(128, 10)
},
forward = function(x) {
x %>%
self$conv1() %>%
nnf_relu() %>%
self$conv2() %>%
nnf_relu() %>%
nnf_max_pool2d(2) %>%
self$dropout1() %>%
torch_flatten(start_dim = 2) %>%
self$fc1() %>%
nnf_relu() %>%
self$dropout2() %>%
self$fc2()
}
)
# 2. Modell laden
model <- luz_load("mnist-cnn.pt")
print(model)
library(magick)
# Bild-URL (Beispiel)
#img <- image_read("../images/Predictfour.png")
img <- image_read("../images/Predictfour.png")
plot(img)
arr <- image_data(img, channels = "gray")
img_matrix <- as.numeric(arr[1, , ])
img_matrix <- matrix(img_matrix, nrow = 28, ncol = 28, byrow = TRUE)
img_matrix <- img_matrix / 255
img_tensor <- torch_tensor(img_matrix, dtype = torch_float())
img_tensor <- img_tensor$unsqueeze(1)$unsqueeze(1)
prediction <- predict(model, img_tensor)
pred_class <- as.array(prediction$argmax(dim = 2))
cat("Vorhergesagte Ziffer:", pred_class, "\n")
# Bild vorbereiten
img_array <- as.numeric(image_data(img, channels = "gray")[1,,])
img_matrix <- matrix(img_array, nrow = 28, ncol = 28)
img_matrix <- img_matrix / 255
# Tensor erzeugen
img_tensor <- torch_tensor(img_matrix, dtype = torch_float())
img_tensor <- img_tensor$unsqueeze(1)$unsqueeze(1)  # [1, 1, 28, 28]
# Vorhersage
prediction <- predict(model, img_tensor)
# Zugriff ohne [[1]] !
pred_class <- as.array(prediction$argmax(dim = 2))
cat("Vorhergesagte Ziffer:", pred_class, "\n")
print("Done")
